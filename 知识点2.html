<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>知识点：原型链与继承</title>
	<script>
	/*
		本节大纲：
			1.了解原型链
			2.对象属性的读取和写入
			3.继承
		---------------------------------------------------
		1.原型链
			原型链：实例与原型对象的链条
			原型搜索机制扩展
				最后搜索到Object构造函数

		2.实例对象属性的读取和写入
			1）读取(原型搜索机制)：
				当代码读取对象的某个属性时，会先从对象实例本身开始搜索。如果在实例中找到了这个属性，则返回该属性的值；如果没有找到，则继续搜索原型对象，如果在原型对象中找到了这个属性，则返回该属性的值

			2）写入：
				虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，该属性将会屏蔽原型中的那个属性。（一句话：添加属性/方法只会在对象实例中添加）

			3）对象属性的遍历与判断
				1> for…in：遍历对象中的所有属性, 无论该属性存在于实例中还是原型中
				2> in：只要通过对象能够访问到属性就返回true, 无论该属性存在于实例中还是原型中
					if(name in s1){}
				3>实例.hasOwnProperty(属性)：检测一个属性是存在于实例中(true)，还是存在于原型中(false)
				4>检测一个属性是否存在于原型中：!obj.hasOwnProperty(name) && (name in obj)

		3.继承
			1）原型链继承
				prototype
				原型链属性(方法)的查找过程：实例-->原型对象-->原型对象... --> Object.prototype
				PS:原型链继承法一般用于继承方法

			2）借用构造函数
				call：使用父类函数的call（子类对象,参数1，参数2，参数3......） 最常见
					格式：构造函数.call(this,参数1,参数2,参数3......)
				apply：使用父类函数的apply（子类对象，[参数1，参数2，参数3]）
					格式：父类构造函数.apply(子类当前对象,[参数1,参数2,参数3......])//第二个参数为数组
				**call与apply的唯一区别：传参方式不同
				**借用构造函数法只能继承构造函数里的属性/方法，不能继承原型对象里的方法
				PS：借用构造函数法一般用于继承属性

			3）组合继承
				继承属性：借用构造函数
				继承方法：原型链继承

				是最常用的继承模式。

			4）原型式继承
				function object(o){
					function F(){}
					F.prototype = o;
					return new F();
				}
				原理：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例
				Object.create()：ECMAScript 5版本的原型式继承

			5）寄生组合继承法
				继承属性：借用构造函数
				继承方法：原型式继承


	</script>
</head>
<body>
	
</body>
</html>